#! /usr/bin/env python3

import json
import time
import signal
import logging
import argparse
import datetime
import subprocess

def interrupt_handler(signum, stack_frame):
  global quit
  log.warning('Shutting down')
  quit = True

parser = argparse.ArgumentParser(description='Repeat a command over and over')
parser.add_argument('command', nargs='+', help='Command and arguments to execute')
parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.WARNING - (args.verbose or 0)*10)

signal.signal(signal.SIGPIPE, lambda signum, stack_frame: exit(0))
signal.signal(signal.SIGINT, interrupt_handler)

def write_results(results):
  with open('repeater.json', 'w') as stream:
    json.dump(results, stream)

results = {
  'command': args.command,
  'results': list(),
}

quit = False

write_results(results)
iteration = 1
while not quit:
  p = subprocess.Popen(args.command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  start = datetime.datetime.now()
  if iteration == 1 or (iteration % 25) == 0:
    print(f'{start!s}: Iteration {iteration}')
  results['results'].append({
    'start': start.isoformat(),
  })

  while not quit:
    time.sleep(0.0005)
    log.debug('polling')
    if p.poll() is None:
      results['results'][-1]['duration'] = str(datetime.datetime.now() - start)
      write_results(results)
    else:
      break

  if p.poll() is None:
    results['results'][-1]['killed'] = True
    log.warning('Shutting down command')
    p.kill()

  (stdout, stderr) = p.communicate()
  rc = p.wait()
  results['results'][-1]['rc'] = rc
  results['results'][-1]['stdout'] = stdout.decode()
  results['results'][-1]['stderr'] = stderr.decode()
  results['results'][-1]['duration'] = str(datetime.datetime.now() - start)
    
  write_results(results)

  iteration += 1
