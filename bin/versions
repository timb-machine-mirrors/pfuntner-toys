#! /usr/bin/env python
# Ideally, this will work for Python 2 or Python 3

import os
import re
import sys
import logging
import argparse
import datetime
import subprocess

from simpletable import Table

def gitdate_to_datetime(groups):
  main = groups[0]
  hours_offset = int(groups[1])
  minutes_offset = int(groups[2])

  date = datetime.datetime.strptime(main, '%a %b %d %H:%M:%S %Y')
  if hours_offset >= 0:
    date -= datetime.timedelta(hours=hours_offset, minutes=minutes_offset)
  else:
    date += datetime.timedelta(hours=-hours_offset, minutes=minutes_offset)
  return date.isoformat().replace('-', '.').replace(':', '').replace('T', '-')

def extract(regexp, line, converter=None):
  ret = None
  match = regexp.search(line)
  if match:
    if converter:
      ret = converter(match.groups())
    else:
      ret = match.group(1)
  return ret

def run(cmd):
  if isinstance(cmd, str):
    cmd = cmd.split()
  log.info('Executing {cmd}'.format(**locals()))
  p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  (stdout, stderr) = tuple([s if sys.version_info.major == 2 else s.decode('utf-8') for s in p.communicate()])

  rc = p.wait()
  log.debug('Executed {cmd}: {rc}, {stdout!r}, {stderr!r}'.format(**locals()))
  return (rc, stdout, stderr)

def get_version(s):
  version = None
  for token in s.split():
    if version_regexp.search(token):
      version = remove_headings.sub('', remove_trailers.sub('', token))
      break
  return version

def look_for(target, dir=None):
  global table

  path = target if dir is None else os.path.join(dir, target)
  if not dir:
    dir = os.path.dirname(target)
  if os.path.isfile(path):
    (rc, stdout, stderr) = run([path, '--version'])
    stdout = (stdout + stderr).replace('\n', ' ').replace('\r', '').strip()
    if args.dumb:
      version = stdout
      initial_stdout = stdout
    else:
      version = get_version(stdout)
      original_version = version
      if not version:
        (rc, stdout, stderr) = run([path, '-version'])
        stdout = (stdout + stderr).replace('\n', ' ').replace('\r', '').strip()
        version = get_version(stdout)
        if not version:
          # tool probably doesn't support --version or -version options - let's try to get the git commit for the file
          version = original_version
          os.chdir(dir)
          (rc, stdout, stderr) = run(['git', 'log', '-1', os.path.basename(target)])
          if rc == 0:
            commit = None
            author = None
            date = None
            messages = ''
  
            for line in stdout.splitlines():
              commit = extract(commit_regexp, line) or commit
              author = extract(author_regexp, line) or author
              date = extract(date_regexp, line, converter=gitdate_to_datetime) or date
              if date is None:
                messages = ''
  
              match = messages_regexp.search(line)
              if match:
                messages += (' ' if messages and not messages.endswith(' ') else '') + match.group(1)
  
            log.info('Commit extractions: {date} {commit} {author} {messages}'.format(**locals()))
            if commit and author and date and messages:
              version = '{date} {commit} {author} {messages}'.format(**locals())
          os.chdir(cwd)

    if args.version:
      print(version)
    else:
      table.add(target, target if dir is None else dir, version)
    return True
  else:
    return False

parser = argparse.ArgumentParser(description='Show command locations and versions')
parser.add_argument('targets', metavar='target', nargs='+', help='One or more targets to locate')

group = parser.add_mutually_exclusive_group()
group.add_argument('-d', '--dumb', action='store_true', help='Do not try to parse out version')
group.add_argument('--version', action='store_true', help='Print out only version - only one argument allowed')

parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.WARNING - (args.verbose or 0)*10)

if args.version and args.targets != 1:
  parser.error('You must specify exactly one target when you specify --version')

# The version must contain a digit followed by a period
version_regexp = re.compile(r'\d\.')

# This regular expression removes trash at beginning of the version
remove_headings = re.compile(r'^"')

# This regular expression removes trash at end of the version
remove_trailers = re.compile(r'[.,"]+$')

# regular expression for processing `git log` output
commit_regexp = re.compile(r'^commit\s+([0-9a-f]{7})(?:[0-9a-f]{33})$') # this only retains the short SHA1: The first 7 characters
author_regexp = re.compile(r'^Author:\s+.*<([^>]+)>$')
date_regexp = re.compile(r'^Date:\s+((?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{1,2}\s\d{2}:\d{2}:\d{2}\s\d{4})\s([-+]\d{2})(\d{2})$')
messages_regexp = re.compile(r'^ {4}(.*)$')

cwd = os.getcwd()

if not args.version:
  table = Table('Name', 'Location', 'Version')

for target in args.targets:
  found = False
  processed = []

  if '/' in target:
    found = look_for(target)

  else:
    for dir in os.environ['PATH'].split(':'):
      if dir not in processed:
        processed.append(dir)
        if look_for(target, dir):
          found = True
          break
      else:
        log.debug('Skipping {dir} since it was already processed'.format(**locals()))

  if not found:
    if args.version:
      print('0')
    else:
      table.add(target, 'n/a', '')

if not args.version:
  table.close()
