#! /usr/bin/env python3

import re
import sys
import json
import signal
import logging
import argparse

# set up some "aliases" so Python evaluation will work
null = None
true = True
false = False

class Char(object):
  def __init__(self, pos, c):
    self.start = pos
    self.stop = None
    self.c = c

  def __str__(self):
    return f'({self.start},{self.c!r})'

def in_string():
  return stack and stack[-1].c in '"\''

def matching(c):
  ret = False
  if stack:
    if c == '}' and stack[-1].c == '{':
      ret = True
    elif c == ']' and stack[-1].c == '[':
      ret = True
    elif c == '"' and stack[-1].c == '"':
      ret = True
    elif c == "'" and stack[-1].c == "'":
      ret = True
  return ret

def pop(pos, c):
  global stack

  if len(stack) > 1:
    del stack[-1]
  else:
    stack[0].stop = pos
    substr = line[stack[0].start:stack[0].stop+1].replace('%!(PACKER_COMMA)', ',')
    log.info(f'Potential Python expression: {substr!r}')
    try:
      # Python might work if:
      #   - None, True, False are present - null, true, false are "ok" but only because we have "aliases"
      #   - Single or double quotes are used for strings
      struct = eval(substr)
      print(json.dumps(struct))
    except Exception as e:
      log.info(f'Caught {e!s} processing {substr!r} as JSON')
      try:
        # JSON might work better if:
        #   - null, true, false are present
        #   - None, True, False are not present
        #   - Single quotes are not used for strings
        #   - There are no unicode, byte strings
        log.info(f'Re-evaluating as JSON structure')
        struct = json.loads(substr)
        print(json.dumps(struct))
      except Exception as e:
        log.info(f'Caught {e!s} processing {substr!r} as JSON')
    del stack[0]

parser = argparse.ArgumentParser(description='Process nearly-JSON data')
parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.WARNING - (args.verbose or 0)*10)

signal.signal(signal.SIGPIPE, lambda signum, stack_frame: exit(0))

if sys.stdin.isatty():
  parser.error('stdin must be redirected')

for (linenum, line) in enumerate(sys.stdin.read().splitlines()):
  log.debug(f'{linenum}: {line!r}')
  escaped = False
  pos = 0
  stack = []

  for (pos, c) in enumerate(line):
    log.debug('{pos} {c!r} {stack!s}'.format(pos=pos, c=c, stack=[str(item) for item in stack]))
    if in_string() and not escaped and c == '\\':
      log.debug(f'Escaping at {pos}: {c!r}')
      escaped = True
    else:
      if escaped:
        log.debug(f'Un-escaping at {pos}: {c!r}')
        escaped = False
      elif in_string():
        if matching(c):
          log.debug(f'Closing string at {pos}: {c!r}')
          pop(pos, c)
      elif c in '"\'':
        log.debug(f'Opening string at {pos}: {c!r}')
        stack.append(Char(pos, c))
      elif c in '[{':
        log.debug(f'Opening element at {pos}: {c!r}')
        stack.append(Char(pos, c))
      elif matching(c):
        log.debug(f'Closing element at {pos}: {c!r}')
        pop(pos, c)
      else:
        log.debug(f'Non-meta at {pos}: {c!r}')
