#! /usr/bin/env python

import re
import sys
import logging
import argparse

def toLeft(s, width):
  return s.ljust(width)

def toRight(s, width):
  return s.rjust(width)

def toCenter(s, width):
  return s.center(width)

def process(lines):
  maxWidth = max([len(line) for line in lines])
  log.debug('maxWidth: {maxWidth}'.format(**locals()))
  print ("%s%s%s" % (topLeftCorner, horizontal * (maxWidth+2), topRightCorner)).encode('utf-8')
  for line in lines:
    print ("%s %s %s" % (vertical, just(line, maxWidth), vertical)).encode('utf-8')
  print ("%s%s%s" % (bottomLeftCorner, horizontal * (maxWidth+2), bottomRightCorner)).encode('utf-8')

def get_color(arg):
  rets = {}

  log.debug('arg: {arg!r}'.format(**locals()))
  normalized_arg = re.sub(r'[-_ ]', '', arg).lower()
  log.debug('normalized_arg: {normalized_arg!r}'.format(**locals()))

  for (key, value) in colors.items():
    if normalized_arg == key[:len(normalized_arg)]:
      rets[key] = value

  if not rets:
    raise argparse.ArgumentTypeError('{arg!r} must be one of: {colors}'.format(
      arg=arg,
      colors=', '.join(colors.keys())
    ))
  elif len(rets) > 1:
    raise argparse.ArgumentTypeError('{arg!r} is ambiguous: {colors}'.format(
      arg=arg,
      colors=', '.join(rets.keys())
    ))

  return rets[rets.keys()[0]]

def print_color(color):
  if color and args.color:
    sys.stdout.write('\x1b[{color}m'.format(**locals()))

colors = {
  'black': '0;30',
  'white': '1;37',
  'red': '0;31',
  'blue': '0;34',
  'purple': '0;35',
  'cyan': '0;36',
  'orange': '0;33',
  'brown': '0;33',
  'green': '0;32',
  'yellow': '1;33',
  'darkgray': '1;30',
  'lightred': '1;31',
  'lightgreen': '1;32',
  'lightblue': '1;34',
  'lightpurple': '1;35',
  'lightcyan': '1;36',
  'lightgray': '0;37',
}

horizontal = unichr(9473)
parser = argparse.ArgumentParser(description='Print a message or information in a pretty banner')

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
# log.setLevel(logging.DEBUG) # uncomment this to enable debugging in get_color() method

group = parser.add_mutually_exclusive_group()
group.add_argument('-C', '--character', dest='character', help='Character to use to construct banner')
group.add_argument('-H', '--hash', dest='hash', action='store_true', help='Construct banner with hash signs rather than cool `line art` characters')

group = parser.add_mutually_exclusive_group()
group.add_argument('-c', '--center', dest='center', action='store_true', help='Center text inside banner')
group.add_argument('-r', '--right', dest='right', action='store_true', help='Right-justify text inside banner')

parser.add_argument('--color', type=get_color, help='Choose a color: {colors}'.format(colors=', '.join(colors.keys())))
parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='Enable debugging')

parser.add_argument('args', metavar='arg', nargs='*', help='Provide a message on the command line')
args = parser.parse_args()

log.setLevel(logging.DEBUG if args.verbose else logging.WARNING)

log.debug('args: {args}'.format(**locals()))

vertical = unichr(9475)

topLeftCorner = unichr(9487)
topRightCorner = unichr(9491)
bottomLeftCorner = unichr(9495)
bottomRightCorner = unichr(9499)

fillChar = '#'

box = True
if args.character:
  box = False
  fillChar = args.character
elif args.hash:
  box = False

just = toLeft
if args.center:
  just = toCenter
elif args.right:
  just = toRight

if not box:
  horizontal = fillChar
  vertical = fillChar

  topLeftCorner = fillChar
  topRightCorner = fillChar
  bottomLeftCorner = fillChar
  bottomRightCorner = fillChar

if (not args) and sys.stdin.isatty():
  syntax("Text must be on the command line or redirected through stdin")

print_color(args.color)

if args.args:
  process([' '.join(args.args)])
else:
  process(sys.stdin.read().strip('\n').split('\n')) 

print_color('0')
