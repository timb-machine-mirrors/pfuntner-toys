#! /usr/bin/env python

import os
import re
import sys
import json
import logging
import argparse

class Measurement(object):
  @staticmethod
  def find(amt, units):
    for measurement in conversions:
      if (not args.measurement) or (measurement['name'] == args.measurement_name):
        if units in measurement['imperial'].keys():
          return Measurement(amt, units, 'imperial', measurement)
        elif units in measurement['metric'].keys():
          return Measurement(amt, units, 'metric', measurement)
    parser.error('Unknown units: {units!r}'.format(**locals()))
  
  def __init__(self, amt, units, system, measurement):
    self.amt = amt
    self.original_amt = amt

    self.units = units
    self.original_units = units

    self.system = system
    self.original_system = system

    self.measurement = measurement
    self.converter = measurement['conversion']['convert']

    self.sorted_units = [key for (key,value) in sorted(
      measurement[system].items(), 
      reverse=True, 
      key=lambda suffix: suffix[1] # sort on value
    )]
    log.debug('sorted_units: {self.sorted_units}'.format(**locals()))

    if hasattr(self.converter, '__call__'):
      self.destination = units
    else:
      self.destination = measurement['conversion']['from'] if measurement['conversion']['from'] in self.sorted_units else measurement['conversion']['to']
    log.debug('destination: {self.destination}'.format(**locals()))

  def convert(self):
    log.debug('self.converter: {self.converter}'.format(**locals()))
    if hasattr(self.converter, '__call__'):
      (amt, units, system) = self.converter(self.amt, self.units)
      return Measurement(amt, units, system, self.measurement)
    else:
      assert False, 'work in progress'

  def __str__(self):
    return '{self.amt} {self.units} {self.system} {measurement_name}'.format(
      measurement_name=self.measurement['name'],
      **locals()
    )

def massage(root):
  """
  Massage `units.json` by interpreting strings which accomplishes two things:
    - converts numeric expressions that are encoded as strings (such as "INT**INT") into numeric values
    - compiles lambda functions into callable functions
  Returns: the same root object passed in, possibly altered
  """
  # log.debug('massage({root})'.format(**locals()))
  if isinstance(root, list):
    map(massage, root)
  elif isinstance(root, dict):
    for (key, value) in root.items():
      if key in ['name', 'from', 'to']:
        pass # no need to massage these fields - they remain as strings
      elif isinstance(value, basestring):
        root[key] = eval(value)
      elif isinstance(value, dict):
        massage(value)
  return root

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.DEBUG if '-v' in sys.argv else logging.WARNING)

conversions = {}
with open(os.path.join(os.path.dirname(sys.argv[0]), 'units.json')) as stream:
  conversions = massage(json.load(stream))

parser = argparse.ArgumentParser(description='Perform unit conversions')
parser.add_argument('-m', '--measurement', dest='measurement', help='Measurement system', choices=[datum['name'] for datum in conversions or []])
parser.add_argument('-v', '--verbose', dest='verbose', action='count', help='Enable more debugging')
parser.add_argument('args', metavar='arg', nargs='+', help='Measurement to convert')
args = parser.parse_args()

log.setLevel(logging.WARNING - 10*(args.verbose or 0))
log.debug('conversions: {conversions}'.format(**locals()))

match = re.search('^((?:\d+\.?\d?)|(?:\d*\.?\d+))(\w+)?$', args.args[0])
if match:
  amt = float(match.group(1))
  if match.group(2):
    units = match.group(2)
    if len(args.args) > 1:
      parser.error('Unexpected arguments: {remain}'.format(remain=' '.join(args.args[1:])))
  else:
    if len(args.args) == 1:
      parser.error('No units found for {amt}'.format(**locals()))
    elif len(args.args) > 2:
      parser.error('Unexpected arguments: {remain}'.format(remain=' '.join(args.args[2:])))
    else:
      units = args.args[1]
  measurement1 = Measurement.find(amt, units)
  log.info('Initial measurement: {measurement}'.format(
    measurement=str(measurement1)
  ))
  measurement2 = measurement1.convert()
  print '{measurement1.amt} {measurement1.units} = {measurement2.amt} {measurement2.units}'.format(**locals())
else:
  parser.error('Unexpected measurement: {arg}'.format(arg=args.args[0]))
