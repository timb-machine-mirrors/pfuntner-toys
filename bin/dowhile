#! /usr/bin/env python2

import re
import sys
import time
import logging
import argparse
import subprocess

def now():
  """
  Return current number of seconds since the epoch
  """
  return time.time()

def formatTime(secs=None):
  if secs == None:
    secs = now()
  return time.strftime("%Y-%m-%d %H:%M:%S.%s", time.localtime(secs))

parser = argparse.ArgumentParser(description='dowhile')
parser.add_argument('-d', '--debug', '--verbose', dest='verbose', action='store_true', help='Enable debugging')
parser.add_argument('-v', '--negate', dest='negate', action='store_true', help='Stop when output has the regular expression')
parser.add_argument('-i', '--ignorerc', dest='ignorerc', action='store_true', help='Ignore command exit status')
parser.add_argument('regexp', help='Regular expression with which to search')
parser.add_argument('cmd', nargs='+', help='COmmand to execute')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.DEBUG if args.verbose else logging.WARNING)

regexp = re.compile(args.regexp)

done = False
while not done:
  print formatTime()
  log.info(args.cmd)
  p = subprocess.Popen(args.cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout = p.stdout.read()
  stderr = p.stderr.read()
  rc = p.wait()
  sys.stdout.write(stdout)
  sys.stderr.write(stderr)
  print ''
  if (not args.ignorerc) and (rc != 0):
    log.debug("Stopping due to rc=%d" % rc)
    done = True
  elif (not args.negate) and ((not regexp.search(stdout)) and (not regexp.search(stderr))):
    log.debug("Stopping due to {regexp.pattern!r} not being in output".format(**locals()))
    done = True
  elif args.negate and ((regexp.search(stdout) or regexp.search(stderr))):
    log.debug("Stopping due to {regexp.pattern!r} being in output".format(**locals()))
    done = True
  else:
    time.sleep(15)
