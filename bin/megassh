#! /usr/bin/env python2

import time
import json
import base64
import logging
import argparse
import subprocess

def echo(host, data):
  for line in data.splitlines():
    print '{host}: {line}'.format(**locals())
  
parser = argparse.ArgumentParser(description='ssh to multiple machines')
parser.add_argument('hosts', help='One or more comma-separated hosts')
parser.add_argument('cmd', help='Command')
parser.add_argument('args', metavar='arg', nargs='*', help='Command arguments')
parser.add_argument('-e', '--encode', action='store_true', help='Use base64 encoding to protect command')
parser.add_argument('-b', '--become', action='store_true', help='Use sudo on remote system')
parser.add_argument('-q', '--quiet', action='store_true', help='Use ssh -q')
parser.add_argument('-j', '--json', action='store_true', help='Produce JSON output')
parser.add_argument('-v', '--verbose', action='store_true', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.DEBUG if args.verbose else logging.WARNING)

processes = {}
for host in args.hosts.split(','):
  remote_cmd = [args.cmd] + (args.args if args.args else [])
  cmd = ['ssh'] + (['-q'] if args.quiet else []) + [host]
  if args.encode:
    cmd += ['bash -c "base64 -d | {sudo} bash"'.format(sudo='sudo' if args.become else '')]
  else:
    cmd += (['sudo'] if args.become else []) + remote_cmd
  log.debug(cmd)
  processes[host] = subprocess.Popen(cmd, stdin=subprocess.PIPE if args.encode else None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  if args.encode:
    processes[host].stdin.write(base64.b64encode(' '.join(remote_cmd)))
    processes[host].stdin.close()

output = {}

secs = .1
while processes:
  time.sleep(secs)
  secs = 1
  hosts = processes.keys()
  for host in hosts:
    p = processes[host]
    if p.poll() is not None:
      if args.encode:
        stdout = p.stdout.read()
        stderr = p.stderr.read()
      else:
        (stdout, stderr) = p.communicate()
      rc = p.wait()
      if args.json:
        output[host] = {
          'rc': rc,
          'stdout': stdout.splitlines(),
          'stderr': stderr.splitlines(),
        }
      else:
        echo(host, stdout)  
        echo(host, stderr)  
      del processes[host]
    else:
      log.debug('{host} still running'.format(**locals()))

if args.json:
  print json.dumps(output, indent=2, sort_keys=True)
