#! /usr/bin/env python3

import time
import json
import base64
import logging
import argparse
import subprocess

def echo(host, data):
  if args.raw:
    if data:
      print('{host}: {data!r}'.format(**locals()))
  else:
    for line in data.splitlines():
      print('{host}: {line}'.format(**locals()))
  
parser = argparse.ArgumentParser(description='ssh to multiple machines')
parser.add_argument('hosts', help='One or more comma-separated hosts')
parser.add_argument('cmd', help='Command')
parser.add_argument('args', metavar='arg', nargs='*', help='Command arguments')
parser.add_argument('-e', '--encode', action='store_true', help='Use base64 encoding to protect command')
parser.add_argument('-b', '--become', action='store_true', help='Use sudo on remote system')
parser.add_argument('-q', '--quiet', action='store_true', help='Use ssh -q')

group = parser.add_mutually_exclusive_group()
group.add_argument('-j', '--json', action='store_true', help='Produce JSON output')
group.add_argument('-r', '--raw', action='store_true', help='Produce raw output')

parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.WARNING - 10*(args.verbose or 0))

log.info(f'args: {args}')

if args.hosts == 'all':
  try:
    p = subprocess.Popen(['ansible-inventory', '--list'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    stdout = stdout.decode('utf-8')
    stderr = stderr.decode('utf-8')
    rc = p.wait()
    args.hosts = ','.join(json.loads(stdout)['targets']['hosts'])
  except Exception as e:
    log.debug(f'Ignoring {e!s} from ansible-inventory')

remote_cmd = [args.cmd] + (args.args if args.args else [])
processes = {}
for host in args.hosts.split(','):
  log.info(f'Creating {remote_cmd} for {host}')
  cmd = ['ssh'] + (['-q'] if args.quiet else []) + [host]
  if args.encode:
    cmd += ['bash -c "base64 -d | {sudo} bash"'.format(sudo='sudo' if args.become else '')]
  else:
    cmd += (['sudo'] if args.become else []) + remote_cmd
  log.debug(cmd)
  processes[host] = subprocess.Popen(cmd, stdin=subprocess.PIPE if args.encode else None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  if args.encode:
    processes[host].stdin.write(base64.b64encode(' '.join(remote_cmd)))
    processes[host].stdin.close()

output = {}

secs = .1
while processes:
  time.sleep(secs)
  secs = .25

  hosts = list(processes.keys())
  log.info(f'hosts: {hosts}')
  for host in hosts:
    log.info(f'host: {host}')
    p = processes[host]
    if p.poll() is not None:
      if args.encode:
        stdout = p.stdout.read().decode('utf-8')
        stderr = p.stderr.read().decode('utf-8')
      else:
        (stdout, stderr) = p.communicate()
        stdout = stdout.decode('utf-8')
        stderr = stderr.decode('utf-8')
      rc = p.wait()
      if args.json:
        output[host] = {
          'rc': rc,
          'stdout': stdout.splitlines(),
          'stderr': stderr.splitlines(),
        }
      else:
        echo(host, stdout)  
        echo(host, stderr)  
      del processes[host]
    else:
      log.debug(f'{host} still running')

if args.json:
  print(json.dumps(output, indent=2, sort_keys=True))
