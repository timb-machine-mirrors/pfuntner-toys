#! /usr/bin/env python2

import time
import json
import logging
import argparse
import subprocess

def echo(host, data):
  for line in data.splitlines():
    print '{host}: {line}'.format(**locals())
  
parser = argparse.ArgumentParser(description='ssh to multiple machines')
parser.add_argument('hosts', help='One or more comma-separated hosts')
parser.add_argument('cmd', help='Command')
parser.add_argument('args', metavar='arg', nargs='*', help='Command arguments')
parser.add_argument('-q', '--quiet', action='store_true', help='Use ssh -q')
parser.add_argument('-j', '--json', action='store_true', help='Produce JSON output')
parser.add_argument('-v', '--verbose', action='store_true', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.DEBUG if args.verbose else logging.WARNING)

processes = {}
for host in args.hosts.split(','):
  cmd = ['ssh'] + (['-q'] if args.quiet else []) + [host, args.cmd] + (args.args if args.args else [])
  log.debug(cmd)
  processes[host] = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

output = {}

secs = .1
while processes:
  time.sleep(secs)
  secs = 1
  hosts = processes.keys()
  for host in hosts:
    p = processes[host]
    if p.poll() is not None:
      (stdout, stderr) = p.communicate()
      rc = p.wait()
      if args.json:
        output[host] = {
          'rc': rc,
          'stdout': stdout.splitlines(),
          'stderr': stderr.splitlines(),
        }
      else:
        echo(host, stdout)  
        echo(host, stderr)  
      del processes[host]
    else:
      log.debug('{host} still running'.format(**locals()))

if args.json:
  print json.dumps(output, indent=2, sort_keys=True)
