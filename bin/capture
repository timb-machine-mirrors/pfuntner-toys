#! /usr/bin/env python3

import sys
import time
# import shlex
import signal
import logging
import argparse
import datetime
import threading
import subprocess

class OutputThread(threading.Thread):
  def __init__(self, label, input_pipe, output_stream):
    self.label = label
    self.input_pipe = input_pipe
    self.output_stream = output_stream
    super().__init__()
    self.start()

  def run(self):
    buf = ''
    start_time = None
    while True:
      log.info(f'{self.label}: reading')
      c = self.input_pipe.read(1)
      if c == '':
        break
      else:
        if start_time is None:
          start_time = datetime.datetime.now().isoformat()
        buf += c
        if c == '\n':
          print(f'{start_time} {buf}', file=self.output_stream, end='')
          buf = ''
          start_time = None
    log.info(f'{self.label}: EOF')
    if buf:
      print(f'{start_time} {buf}', file=self.output_stream)

parser = argparse.ArgumentParser(description='Capture stdout/stderr of a command')
parser.add_argument('command', nargs='+', help='Command and arguments')
parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger(sys.argv[0])
log.setLevel(logging.WARNING - (args.verbose or 0)*10)

signal.signal(signal.SIGPIPE, lambda signum, stack_frame: exit(0))


try:
  # command = shlex.join(args.command)
  command = ' '.join(args.command)
  log.info(f'command={command!r}')
  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1, shell=True)
except Exception as e:
  log.fatal(f'{command} failed: {e!s}')
  exit(1)

stdout = OutputThread('stdout', p.stdout, sys.stdout)
stderr = OutputThread('stderr', p.stderr, sys.stderr)

while stdout.is_alive() or stdout.is_alive():
  time.sleep(.05)

print(f'rc={p.wait()}')
