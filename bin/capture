#! /usr/bin/env python

import sys
import time
import select
import datetime
import threading
import subprocess

def write(stream, stream_name, msg):
  if msg:
    msg = msg.strip('\n')
    lock.acquire()
    stream.write('{now} {stream_name} {msg!r}\n'.format(now=datetime.datetime.now(), **locals()))
    lock.release()

class Redirect(threading.Thread):
  def __init__(self, stream_name, in_stream, out_stream):
    self.stream_name = stream_name
    self.in_stream = in_stream
    self.out_stream = out_stream
    super(Redirect, self).__init__()

  def run(self):
    global lock

    buf = ''
    stream_name = self.stream_name
    while True:
      c = self.in_stream.read(1)
      if c:
        if c == '\n':
          write(self.out_stream, stream_name, buf)
          buf = ''
        else:
          buf += c
      else:
        break
    write(self.out_stream, stream_name, buf)

def syntax(msg=None):
  if msg:
    sys.stderr.write('{msg}\n'.format(**locals()))
  sys.stderr.write('{pgm} cmd ...\n'.format(pgm=sys.argv[0]))
  exit(1)

def redirect(p, stream_name):
  global threads
  threads.append(Redirect(stream_name, getattr(p, stream_name), getattr(sys, stream_name)))
  threads[-1].start() 

if len(sys.argv) < 2:
  syntax()

threads = []
lock = threading.Lock()

start = datetime.datetime.now()
p = subprocess.Popen(sys.argv[1:], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
redirect(p, 'stdout')
redirect(p, 'stderr')
rc = p.wait()
finish = datetime.datetime.now()

while any([thread.isAlive() for thread in threads]):
  time.sleep(.1)

print 'Elapsed time: {elapsed}s'.format(elapsed=finish-start)
