#! /usr/bin/env python

import sys
import time
import select
import datetime
import threading
import subprocess

def write(stream, stream_name, msg):
  if msg:
    msg = msg.strip('\n')
    lock.acquire()
    now = datetime.datetime.now()
    elapsed = now - start
    stream.write('{now} +{elapsed} {stream_name} {msg!r}\n'.format(**locals()))
    lock.release()

class Redirect(threading.Thread):
  def __init__(self, stream_name, in_stream, out_stream):
    self.stream_name = stream_name
    self.in_stream = in_stream
    self.out_stream = out_stream
    super(Redirect, self).__init__()

  def run(self):
    global lock

    buf = ''
    stream_name = self.stream_name
    read_list = [self.in_stream]
    write_list = []
    excp_list = write_list
    last_c = None
    while True:
      (read_ready, write_ready, excp_ready) = select.select(read_list, write_list, excp_list, 1)
      if read_ready:
        c = self.in_stream.read(1)
        if c:
          if c == '\n':
            write(self.out_stream, stream_name, buf)
            buf = ''
          else:
            buf += c
          last_c = c
        else:
          write(self.out_stream, stream_name, buf)
          break
      elif last_c not in [None, '\n']:
        """
        The select() timed out.  If the command printed out some data without a newline, it likely printed out a prompt
        and we would like to display it.
        """
        write(self.out_stream, stream_name, buf)
        buf = ''

def syntax(msg=None):
  if msg:
    sys.stderr.write('{msg}\n'.format(**locals()))
  sys.stderr.write('{pgm} cmd ...\n'.format(pgm=sys.argv[0]))
  exit(1)

def redirect(p, stream_name):
  global threads
  threads.append(Redirect(stream_name, getattr(p, stream_name), getattr(sys, stream_name)))
  threads[-1].start() 

if len(sys.argv) < 2:
  syntax()

threads = []
lock = threading.Lock()

start = datetime.datetime.now()
p = subprocess.Popen(sys.argv[1:], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
redirect(p, 'stdout')
redirect(p, 'stderr')
rc = p.wait()
finish = datetime.datetime.now()

while any([thread.isAlive() for thread in threads]):
  time.sleep(.1)

print 'Elapsed time: {elapsed}s'.format(elapsed=finish-start)
