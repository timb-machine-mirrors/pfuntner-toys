#! /usr/bin/env python3

import re
import sys
import signal
import logging
import inspect
import argparse
import datetime

from simpletable import Table

def get_method():
  # I stole this from https://stackoverflow.com/questions/5067604/determine-function-name-from-within-that-function-without-using-traceback
  return inspect.stack()[1].function
  
def epoch_processor(specimen):
  # Process '1642395600.0'
  ret = None
  method = get_method()

  log.debug(f'{method} testing {specimen!r}')
  match = re.search(r'(\d{10,})(\.\d*)?', specimen)
  log.debug(f'match groups: {match.groups() if match else None}')
  if match and len(match.group(1)) == 10:
    ret = datetime.datetime.fromtimestamp(float(match.group(0)))

  if ret is None:
    log.debug(f'{method} does not recognize {specimen!r}')
  else:
    log.info(f'{method} interpreted {specimen!r} as {ret!r}')

  return ret

def date001_processor(specimen):
  # Process 'Jan 19 2022 12:21:21'
  ret = None
  method = get_method()

  log.debug(f'{method} testing {specimen!r}')
  pattern = r'(Jan|Feb|Mar|May|Apr|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (' + ('|'.join([f'[ 0]?{num}' for num in range(1,10)] + [str(num).rjust(2, '0') for num in range(10,13)])) + ') (\d+) \d{2}:\d{2}:(\d{2,})'
  match = re.search(pattern, specimen)
  log.debug(f'match groups from {pattern!r}: {match.groups() if match else None}')
  if match:
    if len(match.group(3)) == 4 and (1 <= int(match.group(2).strip()) <= 31) and len(match.group(4)) == 2:
      ret = datetime.datetime.strptime(specimen, '%b %d %Y %H:%M:%S')

  if ret is None:
    log.debug(f'{method} does not recognize {specimen!r}')
  else:
    log.info(f'{method} interpreted {specimen!r} as {ret!r}')

  return ret

def date999_processor(specimen):
  # Process '2021-12-10'
  ret = None
  method = get_method()

  log.debug(f'{method} testing {specimen!r}')
  pattern = r'(\d+)-(' + ('|'.join([str(num).rjust(2, '0') for num in range(1,13)])) + ')-(\d+)'
  match = re.search(pattern, specimen)
  log.debug(f'match groups from {pattern!r}: {match.groups() if match else None}')
  if match:
    if len(match.group(1)) == 4 and (1 <= int(match.group(3)) <= 31):
      ret = datetime.datetime.strptime(specimen, '%Y-%m-%d')

  if ret is None:
    log.debug(f'{method} does not recognize {specimen!r}')
  else:
    log.info(f'{method} interpreted {specimen!r} as {ret!r}')

  return ret

def now_processor(specimen):
  # Process 'now'
  ret = None
  method = get_method()

  log.debug(f'{method} testing {specimen!r}')
  pattern = r'\bnow\b'
  match = re.search(pattern, specimen)
  log.debug(f'match groups from {pattern!r}: {match.groups() if match else None}')
  if match:
    ret = datetime.datetime.now()

  if ret is None:
    log.debug(f'{method} does not recognize {specimen!r}')
  else:
    log.info(f'{method} interpreted {specimen!r} as {ret!r}')

  return ret

def process(specimen):
  global table

  ts = None
  for processor in sorted(processors.keys()):
    ts = processors[processor](specimen)
    if ts is not None:
      break

  table.add(specimen, None if ts is None else ts.strftime('%a %b %d %Y %H:%M:%S'), None if ts is None else ts.isoformat(), None if ts is None else ts.timestamp())

parser = argparse.ArgumentParser(description='Interpret date/times')
parser.add_argument('specimens', metavar='specimen', nargs='*', help='Zero or more specimens to interpret')
parser.add_argument('-v', '--verbose', action='count', help='Enable debugging')
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s %(levelname)s %(pathname)s:%(lineno)d %(msg)s')
log = logging.getLogger()
log.setLevel(logging.WARNING - (args.verbose or 0)*10)

signal.signal(signal.SIGPIPE, lambda signum, stack_frame: exit(0))

# I stole this technique from https://stackoverflow.com/questions/18451541/getting-a-list-of-locally-defined-functions-in-python
processors = {key: value for key, value in locals().items() if callable(value) and value.__module__ == __name__ and key.endswith('_processor')}
log.info(f'processors: {processors}')

if args.specimens:
  table = Table('Specimen', 'Human', 'ISO', 'Secs since epoch')
  for specimen in args.specimens:
    process(specimen)
  table.close()
else:
  if sys.stdin.isatty():
    parser.error('stdin must be redirected if no specimens are specified')
  table = Table('Specimen', 'Human', 'ISO', 'Secs since epoch')
  for specimen in sys.stdin.read().splitlines():
    process(specimen)
  table.close()
